# Fyle Integrations App - Cursor Rules

## Angular & TypeScript Best Practices

### Component Structure
- Always implement OnDestroy interface when using subscriptions
- Use proper cleanup with takeUntil pattern for RxJS subscriptions
- Declare component properties with proper TypeScript types
- Use readonly for properties that shouldn't change
- Initialize boolean properties explicitly (e.g., `isLoading: boolean = false`)

### Service & API Patterns
- Always handle errors in service calls with proper error handling
- Use proper typing for API responses instead of `any`
- Implement proper loading states for async operations
- Use forkJoin for parallel API calls when appropriate

### Code Quality
- No console.log statements in production code
- No debugger statements
- Remove TODO comments before submitting for review
- No commented-out code blocks
- Use meaningful variable and method names
- Avoid magic numbers - use constants instead

### Angular Specific
- Use trackBy functions for *ngFor when dealing with dynamic lists
- Prefer OnPush change detection strategy when appropriate
- Use async pipe instead of manual subscription management where possible
- Follow Angular naming conventions (camelCase for properties, PascalCase for classes)

### RxJS Best Practices
- Always unsubscribe from observables to prevent memory leaks
- Use proper operators (map, switchMap, mergeMap, etc.) based on use case
- Chain operators efficiently
- Use takeUntil with destroy$ pattern for subscription cleanup

### HTML Templates
- Use proper Angular directives (*ngIf, *ngFor, etc.)
- Avoid complex expressions in templates
- Use proper accessibility attributes (aria-labels, roles, etc.)
- Prefer Angular Material components over custom implementations when available

### Testing
- Write unit tests for all public methods
- Mock dependencies properly in tests
- Test both success and error scenarios
- Achieve minimum 80% code coverage

### Import Organization
- Group imports: Angular core, third-party, application modules
- Remove unused imports
- Use absolute paths for application modules
- Order imports alphabetically within groups

### Error Handling
- Always implement proper error handling for HTTP calls
- Display user-friendly error messages
- Log errors appropriately for debugging
- Use try-catch blocks for synchronous error-prone operations

### Performance
- Avoid unnecessary DOM manipulations
- Use OnPush change detection when possible
- Lazy load modules and components when appropriate
- Optimize large lists with virtual scrolling

### Accessibility
- Include proper ARIA labels and roles
- Ensure keyboard navigation support
- Maintain proper color contrast ratios
- Add focus management for dynamic content

### Security
- Sanitize user inputs
- Use Angular's built-in XSS protection
- Avoid innerHTML usage without sanitization
- Validate all form inputs

### Specific to Fyle Integrations App
- Follow existing branding configuration patterns
- Use established service patterns for API calls
- Maintain consistency with existing component structure
- Follow the established routing patterns
- Use proper tracking service calls for analytics
- Implement proper toast notifications for user feedback

### Code Style
- Use strict TypeScript configuration
- Follow Angular style guide conventions
- Use proper indentation (2 spaces)
- Maximum line length of 120 characters
- Use single quotes for strings consistently
- Add proper JSDoc comments for public APIs

### Git & PR Best Practices
- Write clear, descriptive commit messages
- Keep PRs focused and small
- Update documentation when adding new features
- Ensure all tests pass before submitting
- Address all linting errors and warnings

## Ashwin's Review Feedback Patterns (Based on PR #1309)

### Type Safety & Enums
- Don't use optional `?` for keys that will always be present in models
- Define enums instead of using string literals for component inputs
- Use enums consistently instead of string comparisons (e.g., `if (this.interactionType === "BOOK_SLOT")` should use enum)
- Always prefer type-safe approaches over loose string typing

### Branding & Configuration
- Never hardcode brand names like "Fyle" - always use `brandingConfig.brandName` variable
- Use `assets/${brandingConfig.brandId}/favicon.png` instead of hardcoded asset paths
- Move URLs to KB article variables instead of hardcoding them directly in components
- Use branding configuration for all brand-specific content

### CSS & Styling Conventions
- Declare custom dimensions in tailwind.config.js instead of using arbitrary values like `tw-h-[76px]`
- Avoid arbitrary values `tw-[something]` wherever possible - define them in config
- Use `px` consistently everywhere in CSS classes
- Maintain consistent spacing and sizing patterns

### UX & Form Validation
- Don't enable save/submit buttons if user hasn't typed anything - implement proper disabled state
- Handle form validation at the UI level, not just with error messages after submission
- Provide immediate feedback for form states rather than post-submission validation
- Implement proper button state management based on form validity

### Backward Compatibility
- Always verify that changes don't affect existing functionality (e.g., "make sure this doesn't affect old QBD app")
- Consider impact on existing integrations when making shared component changes
- Test cross-integration compatibility when modifying shared components
- Maintain separate logic paths for different app variants when necessary

### Code Organization
- Move hardcoded URLs to appropriate configuration files or constants
- Use consistent naming patterns that match existing codebase conventions
- Ensure proper separation of concerns between components and configuration
- Follow established patterns for similar functionality in the codebase 