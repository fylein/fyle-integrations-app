---
description: 
globs: 
alwaysApply: false
---
# Integration Development Guidelines

## Integration Architecture Overview

Each integration in the Fyle Integrations App follows a consistent three-tier architecture:
1. **Onboarding Flow**: Initial setup and configuration
2. **Main Dashboard**: Ongoing management and monitoring
3. **Shared Components**: Reusable integration-specific components

## Adding New Integrations

### 1. Folder Structure
Create new integration following the established pattern:
```
src/app/integrations/{integration-name}/
├── {integration-name}.module.ts
├── {integration-name}-routing.module.ts
├── {integration-name}.component.ts/html/scss
├── {integration-name}-main/
│   ├── dashboard/
│   ├── export-log/
│   └── configuration/
├── {integration-name}-onboarding/
│   ├── connector/
│   ├── configuration/
│   ├── advanced-settings/
│   ├── import-settings/
│   ├── export-settings/
│   └── onboarding-done/
└── {integration-name}-shared/
    ├── components/
    └── services/
```

### 2. Module Setup
```typescript
// {integration}.module.ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { SharedModule } from '../shared/shared.module';
import { IntegrationRoutingModule } from './{integration}-routing.module';

@NgModule({
  declarations: [
    // Integration components
  ],
  imports: [
    CommonModule,
    SharedModule,
    IntegrationRoutingModule
  ]
})
export class IntegrationModule { }
```

### 3. Routing Configuration
Update [src/app/integrations/integrations-routing.module.ts](mdc:src/app/integrations/integrations-routing.module.ts):
```typescript
{
  path: '{integration_name}',
  loadChildren: () => import('./{integration-name}/{integration-name}.module').then(m => m.IntegrationModule)
}
```

### 4. Models ([src/app/core/models/{integration}/](mdc:src/app/core/models))
Create integration-specific models extending common interfaces:
```typescript
// Example: QBO models structure
export interface QboCredentials extends Credentials {
  realm_id: string;
  company_name: string;
  country: string;
}

export interface QboConfiguration extends Configuration {
  import_categories: boolean;
  import_items: boolean;
  sync_fyle_to_qbo_payments: boolean;
}
```

### 5. Services ([src/app/core/services/{integration}/](mdc:src/app/core/services))
Implement API service following established patterns:
```typescript
@Injectable({
  providedIn: 'root'
})
export class IntegrationService extends BaseApiService {
  constructor(
    http: HttpClient,
    apiService: ApiService
  ) {
    super(http, apiService);
  }

  @Cacheable({ maxAge: 5 * 60 * 1000 })
  getConfiguration(): Observable<Configuration> {
    return this.get('/configuration/');
  }

  updateConfiguration(configuration: Configuration): Observable<Configuration> {
    return this.post('/configuration/', configuration);
  }
}
```

### 6. Route Guards
Create integration-specific token guard:
```typescript
@Injectable({
  providedIn: 'root'
})
export class IntegrationTokenGuard {
  constructor(
    private router: Router,
    private integrationService: IntegrationService
  ) {}

  canActivate(): Observable<boolean> {
    return this.integrationService.getCredentials().pipe(
      map(credentials => !!credentials),
      catchError(() => {
        this.router.navigate(['/integrations/{integration}/onboarding/connector']);
        return of(false);
      })
    );
  }
}
```

### 7. Onboarding Components
Create onboarding components following this structure:
```typescript
@Component({
  selector: 'app-integration-connector',
  templateUrl: './integration-connector.component.html',
  styleUrls: ['./integration-connector.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class IntegrationConnectorComponent implements OnInit, OnDestroy {
  form: FormGroup;
  isLoading: boolean;
  private destroy$ = new Subject<void>();
  
  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private integrationService: IntegrationService
  ) { }
  
  ngOnInit(): void {
    this.createForm();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  connect(): void {
    if (this.form.valid) {
      this.isLoading = true;
      this.integrationService.connect(this.form.value)
        .pipe(
          takeUntil(this.destroy$),
          finalize(() => this.isLoading = false)
        )
        .subscribe(() => {
          this.router.navigate(['/integrations/{integration}/onboarding/configuration']);
        });
    }
  }
  
  private createForm(): void {
    this.form = this.formBuilder.group({
      // Connection form fields
    });
  }
}
```

### 8. Configuration Components
Create configuration forms for integration settings:

```typescript
@Component({
  selector: 'app-integration-configuration',
  templateUrl: './integration-configuration.component.html',
  styleUrls: ['./integration-configuration.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class IntegrationConfigurationComponent implements OnInit, OnDestroy {
  form: FormGroup;
  configuration: Configuration;
  isLoading: boolean;
  private destroy$ = new Subject<void>();
  
  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private integrationService: IntegrationService
  ) { }
  
  ngOnInit(): void {
    this.getConfiguration();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  save(): void {
    if (this.form.valid) {
      this.isLoading = true;
      this.integrationService.updateConfiguration(this.form.value)
        .pipe(
          takeUntil(this.destroy$),
          finalize(() => this.isLoading = false)
        )
        .subscribe(() => {
          this.router.navigate(['/integrations/{integration}/onboarding/advanced-settings']);
        });
    }
  }
  
  private getConfiguration(): void {
    this.isLoading = true;
    this.integrationService.getConfiguration()
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(configuration => {
        this.configuration = configuration;
        this.createForm(configuration);
      });
  }
  
  private createForm(configuration: Configuration): void {
    this.form = this.formBuilder.group({
      // Configuration form fields
    });
  }
}
```

## Existing Integration Patterns

### QuickBooks Online (QBO) - Reference Implementation
- **Location**: [src/app/integrations/qbo/](mdc:src/app/integrations/qbo)
- **Models**: [src/app/core/models/qbo/](mdc:src/app/core/models/qbo)
- **Services**: [src/app/core/services/qbo/](mdc:src/app/core/services/qbo)
- **Features**: Complete OAuth flow, advanced mapping, export scheduling
- **Guard**: [src/app/core/guard/qbo-token.guard.ts](mdc:src/app/core/guard/qbo-token.guard.ts)

### NetSuite - Complex Mapping Example
- **Location**: [src/app/integrations/netsuite/](mdc:src/app/integrations/netsuite)
- **Features**: Subsidiary mapping, complex field mapping, custom segments
- **Components**: [src/app/shared/components/netsuite/](mdc:src/app/shared/components/netsuite)
- **Connection Form**: [src/app/integrations/netsuite/netsuite-shared/netsuite-connection-form/](mdc:src/app/integrations/netsuite/netsuite-shared/netsuite-connection-form)

### Sage Intacct - Advanced Configuration
- **Location**: [src/app/integrations/intacct/](mdc:src/app/integrations/intacct)
- **Features**: Location entity mapping, dimension mapping, advanced settings
- **Components**: [src/app/shared/components/si/](mdc:src/app/shared/components/si)
- **Connection Form**: [src/app/integrations/intacct/intacct-shared/intacct-connection-form/](mdc:src/app/integrations/intacct/intacct-shared/intacct-connection-form)

### Sage 300 - Token-based Authentication
- **Location**: [src/app/integrations/sage300/](mdc:src/app/integrations/sage300)
- **Features**: Token-based authentication, custom connection flow
- **Connection Form**: [src/app/integrations/sage300/sage300-shared/sage300-connection-form/](mdc:src/app/integrations/sage300/sage300-shared/sage300-connection-form)

## Common Integration Features

### 1. Onboarding Flow
Standard onboarding steps for all integrations:
1. **Connector**: OAuth or credential-based connection
2. **Configuration**: Basic integration settings
3. **Import Settings**: Data import configuration
4. **Advanced Settings**: Optional advanced features
5. **Export Settings**: Export frequency and triggers
6. **Onboarding Done**: Completion confirmation

### 2. Connection Management
- **OAuth Flow**: Standardized OAuth 2.0 implementation
- **Credential Storage**: Secure token management
- **Connection Status**: Real-time connection validation
- **Reconnection**: Automated token refresh and manual reconnection

### 3. Field Mapping
Common mapping types across integrations:
- **Employee Mapping**: Fyle employees to accounting system employees
- **Category Mapping**: Expense categories to chart of accounts
- **Project Mapping**: Fyle projects to accounting projects/customers
- **Cost Center Mapping**: Fyle cost centers to accounting departments
- **Custom Field Mapping**: Custom fields between systems

### 4. Configuration Settings
Standard configuration options:
- **Import Settings**: What data to import from the accounting system
- **Export Settings**: Export frequency, triggers, and grouping
- **Advanced Settings**: Integration-specific advanced features
- **Employee Settings**: Employee invitation and management

### 5. Export Management
- **Export Logs**: [src/app/shared/components/export-log/](mdc:src/app/shared/components/export-log) - Export history and status
- **Error Handling**: Detailed error logs and resolution guidance
- **Retry Mechanisms**: Automatic and manual retry options
- **Export Scheduling**: Configurable export frequencies

### 6. Dashboard Components
- **Export Summary**: Recent export statistics
- **Error Summary**: Current error counts and types
- **Connection Status**: Integration health monitoring
- **Quick Actions**: Common tasks and shortcuts

## Integration-Specific Considerations

### Authentication Patterns
Different integrations use various authentication methods:

#### OAuth 2.0 Flow (QBO, Xero, Business Central)
```typescript
// OAuth configuration in environment
{
  "{integration}_oauth_client_id": "client_id",
  "{integration}_oauth_redirect_uri": "redirect_uri",
  "{integration}_authorize_uri": "auth_uri"
}

// OAuth service implementation
@Injectable({
  providedIn: 'root'
})
export class OAuthService {
  constructor(
    private apiService: ApiService,
    private router: Router,
    private windowReference: WindowReference
  ) { }

  connectToIntegration(): void {
    // Get OAuth URI from environment
    const oauthUrl = this.apiService.getOAuthUri();
    
    // Open OAuth window
    this.windowReference.nativeWindow.open(oauthUrl, '_blank');
  }

  handleRedirect(code: string): Observable<any> {
    // Exchange code for token
    return this.apiService.exchangeCodeForToken(code);
  }
}

// OAuth callback component
@Component({
  selector: 'app-oauth-callback',
  template: '<div class="loading">Processing authentication...</div>'
})
export class OAuthCallbackComponent implements OnInit {
  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private oauthService: OAuthService
  ) { }

  ngOnInit(): void {
    this.route.queryParams.pipe(
      take(1),
      switchMap(params => {
        const code = params['code'];
        if (!code) {
          return throwError(() => new Error('No code provided'));
        }
        return this.oauthService.handleRedirect(code);
      })
    ).subscribe({
      next: () => this.router.navigate(['/integrations/onboarding/configuration']),
      error: () => this.router.navigate(['/integrations/onboarding/connector'])
    });
  }
}
```

#### Token-based Authentication (Sage Intacct, Sage 300)
```typescript
// Token-based connection
interface TokenCredentials {
  si_user_id: string;
  si_user_password: string;
  si_company_id: string;
  si_company_name: string;
}

// Token service implementation
@Injectable({
  providedIn: 'root'
})
export class TokenService {
  constructor(
    private apiService: ApiService
  ) { }

  connectWithCredentials(credentials: TokenCredentials): Observable<any> {
    return this.apiService.post('/connect/', credentials);
  }

  validateConnection(): Observable<boolean> {
    return this.apiService.get('/validate/').pipe(
      map(() => true),
      catchError(() => of(false))
    );
  }
}

// Token connector component
@Component({
  selector: 'app-token-connector',
  templateUrl: './token-connector.component.html'
})
export class TokenConnectorComponent implements OnInit, OnDestroy {
  form: FormGroup;
  isLoading = false;
  isSubmitting = false;
  private destroy$ = new Subject<void>();
  
  constructor(
    private formBuilder: FormBuilder,
    private tokenService: TokenService,
    private router: Router,
    private messageService: MessageService
  ) { }
  
  ngOnInit(): void {
    this.createForm();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  connect(): void {
    if (this.form.valid) {
      this.isSubmitting = true;
      this.tokenService.connectWithCredentials(this.form.value)
        .pipe(
          takeUntil(this.destroy$),
          finalize(() => this.isSubmitting = false)
        )
        .subscribe({
          next: () => {
            this.messageService.add({
              severity: 'success',
              summary: 'Connection Successful',
              detail: 'Your account has been connected successfully.'
            });
            this.router.navigate(['/integrations/onboarding/configuration']);
          },
          error: (error) => {
            this.messageService.add({
              severity: 'error',
              summary: 'Connection Failed',
              detail: error.message || 'Failed to connect. Please check your credentials.'
            });
          }
        });
    }
  }
  
  private createForm(): void {
    this.form = this.formBuilder.group({
      user_id: ['', Validators.required],
      user_password: ['', Validators.required],
      company_id: ['', Validators.required],
      company_name: ['', Validators.required]
    });
  }
}
```

#### Direct Integration (QBD Direct)
```typescript
// Direct desktop integration
interface DirectCredentials {
  is_desktop_connected: boolean;
  company_file_path: string;
  last_synced_at: string;
}

// Direct connection service
@Injectable({
  providedIn: 'root'
})
export class DirectConnectionService {
  constructor(
    private apiService: ApiService
  ) { }

  checkConnectionStatus(): Observable<DirectCredentials> {
    return this.apiService.get('/connection/');
  }

  connectDesktopApp(settings: any): Observable<any> {
    return this.apiService.post('/connect/', settings);
  }
}

// Direct connector component
@Component({
  selector: 'app-direct-connector',
  templateUrl: './direct-connector.component.html'
})
export class DirectConnectorComponent implements OnInit, OnDestroy {
  connectionStatus: DirectCredentials;
  isLoading = false;
  private destroy$ = new Subject<void>();
  
  constructor(
    private directConnectionService: DirectConnectionService,
    private router: Router,
    private messageService: MessageService
  ) { }
  
  ngOnInit(): void {
    this.checkConnectionStatus();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  checkConnectionStatus(): void {
    this.isLoading = true;
    this.directConnectionService.checkConnectionStatus()
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(status => {
        this.connectionStatus = status;
      });
  }
  
  connect(): void {
    this.isLoading = true;
    this.directConnectionService.connectDesktopApp({ start_connection: true })
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe({
        next: () => {
          this.messageService.add({
            severity: 'success',
            summary: 'Connection Initiated',
            detail: 'Please follow instructions in the desktop application.'
          });
          this.checkConnectionStatus();
        },
        error: (error) => {
          this.messageService.add({
            severity: 'error',
            summary: 'Connection Failed',
            detail: error.message || 'Failed to connect. Please ensure desktop app is running.'
          });
        }
      });
  }
}
```

### Implementing Mapping Components

Mapping components are used throughout the integrations to map Fyle data to accounting system data:

```typescript
@Component({
  selector: 'app-mapping-component',
  templateUrl: './mapping.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class MappingComponent implements OnInit, OnDestroy {
  mappings: MappingItem[] = [];
  sourceOptions: SourceOption[] = [];
  destinationOptions: DestinationOption[] = [];
  isLoading: boolean;
  
  private destroy$ = new Subject<void>();
  
  constructor(
    private mappingService: MappingService
  ) { }
  
  ngOnInit(): void {
    this.loadData();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  createMapping(source: string, destination: string): void {
    this.isLoading = true;
    this.mappingService.createMapping({ source, destination })
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(newMapping => {
        this.mappings = [...this.mappings, newMapping];
      });
  }
  
  deleteMapping(id: number): void {
    this.isLoading = true;
    this.mappingService.deleteMapping(id)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(() => {
        this.mappings = this.mappings.filter(mapping => mapping.id !== id);
      });
  }
  
  private loadData(): void {
    forkJoin([
      this.mappingService.getMappings(),
      this.mappingService.getSourceOptions(),
      this.mappingService.getDestinationOptions()
    ])
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(([mappings, sourceOptions, destinationOptions]) => {
        this.mappings = mappings;
        this.sourceOptions = sourceOptions;
        this.destinationOptions = destinationOptions;
      });
  }
}
```

### Export Settings Configuration

Export settings components are used to configure how data is exported to accounting systems:

```typescript
@Component({
  selector: 'app-export-settings',
  templateUrl: './export-settings.component.html',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ExportSettingsComponent implements OnInit, OnDestroy {
  form: FormGroup;
  exportOptions = [
    { label: 'Expense Report', value: 'EXPENSE_REPORT' },
    { label: 'Journal Entry', value: 'JOURNAL_ENTRY' }
  ];
  isLoading: boolean;
  
  private destroy$ = new Subject<void>();
  
  constructor(
    private formBuilder: FormBuilder,
    private exportService: ExportService,
    private router: Router
  ) { }
  
  ngOnInit(): void {
    this.loadSettings();
  }
  
  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
  
  save(): void {
    if (this.form.valid) {
      this.isLoading = true;
      this.exportService.saveSettings(this.form.value)
        .pipe(
          takeUntil(this.destroy$),
          finalize(() => this.isLoading = false)
        )
        .subscribe(() => {
          this.router.navigate(['/integrations/onboarding/done']);
        });
    }
  }
  
  private loadSettings(): void {
    this.isLoading = true;
    this.exportService.getSettings()
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.isLoading = false)
      )
      .subscribe(settings => {
        this.createForm(settings);
      });
  }
  
  private createForm(settings: any): void {
    this.form = this.formBuilder.group({
      export_type: [settings?.export_type || 'EXPENSE_REPORT', Validators.required],
      frequency: [settings?.frequency || 'DAILY', Validators.required],
      auto_map_employees: [settings?.auto_map_employees || false],
      is_enabled: [settings?.is_enabled || false]
    });
  }
}
```

### Data Synchronization Patterns
- **Incremental Sync**: Only sync changed data since last sync
- **Full Sync**: Complete data refresh when needed
- **Conflict Resolution**: Handle data conflicts between systems
- **Data Validation**: Ensure data integrity before sync

```typescript
// Sync service implementation
@Injectable({
  providedIn: 'root'
})
export class SyncService {
  constructor(
    private apiService: ApiService,
    private storageService: StorageService
  ) { }

  // Incremental sync with timestamp
  syncCategories(): Observable<any> {
    const lastSync = this.storageService.get('last_category_sync') || '1970-01-01T00:00:00Z';
    
    return this.apiService.post('/sync/categories/', { last_sync: lastSync }).pipe(
      tap(response => {
        this.storageService.set('last_category_sync', new Date().toISOString());
        return response;
      })
    );
  }

  // Full sync
  forceSyncAll(): Observable<any> {
    return this.apiService.post('/sync/all/', { force: true }).pipe(
      tap(() => {
        this.storageService.set('last_sync', new Date().toISOString());
      })
    );
  }

  // Check sync status
  checkSyncStatus(): Observable<SyncStatus> {
    return this.apiService.get<SyncStatus>('/sync/status/');
  }
}
```

### Error Handling Strategies
- **Integration-specific Error Codes**: Custom error handling per integration
- **User-friendly Messages**: Clear error descriptions and resolution steps
- **Retry Logic**: Automatic retry for transient failures
- **Support Integration**: Error reporting and support ticket creation

```typescript
// Error handler implementation
@Injectable({
  providedIn: 'root'
})
export class IntegrationErrorHandler {
  constructor(
    private messageService: MessageService,
    private sentryService: SentryService
  ) { }

  handleError(error: any, integration: string): void {
    // Log to monitoring service
    this.sentryService.captureException(error, { integration });

    // Extract error details
    const errorDetails = this.getErrorDetails(error, integration);
    
    // Show user-friendly message
    this.messageService.add({
      severity: 'error',
      summary: errorDetails.title,
      detail: errorDetails.message,
      life: 5000
    });
  }

  private getErrorDetails(error: any, integration: string): { title: string, message: string } {
    // Integration-specific error mapping
    if (integration === 'qbo') {
      return this.mapQboError(error);
    } else if (integration === 'netsuite') {
      return this.mapNetSuiteError(error);
    }
    
    // Default error handling
    return {
      title: 'Error',
      message: error.message || 'An unknown error occurred. Please try again.'
    };
  }

  private mapQboError(error: any): { title: string, message: string } {
    // QBO-specific error codes
    if (error.status === 401) {
      return {
        title: 'Authentication Failed',
        message: 'Your QuickBooks connection needs to be refreshed. Please reconnect.'
      };
    }
    
    // Other QBO errors...
    
    return {
      title: 'QuickBooks Error',
      message: error.message || 'An error occurred with your QuickBooks connection.'
    };
  }

  private mapNetSuiteError(error: any): { title: string, message: string } {
    // NetSuite-specific error handling
    // ...
  }
}
```

## Multi-tenant Branding

### Branding Configuration
- **Base Config**: [src/app/branding/branding-config.ts](mdc:src/app/branding/branding-config.ts)
- **Fyle Branding**: [src/app/branding/fyle-branding-config.ts](mdc:src/app/branding/fyle-branding-config.ts)
- **C1 Branding**: [src/app/branding/c1-branding-config.ts](mdc:src/app/branding/c1-branding-config.ts)

### Brand-specific Features
```typescript
// Feature flags per brand
export const brandingFeatureConfig = {
  fyle: {
    showAdvancedSettings: true,
    allowCustomFields: true,
    supportMultipleCurrencies: true
  },
  co: {
    showAdvancedSettings: false,
    allowCustomFields: false,
    supportMultipleCurrencies: false
  }
};
```

### Integration Feature Toggling
```typescript
// Integration feature service
@Injectable({
  providedIn: 'root'
})
export class IntegrationFeatureService {
  constructor(
    private brandingService: BrandingService
  ) { }

  isFeatureEnabled(featureName: string): boolean {
    const brand = this.brandingService.getBrand();
    const featureConfig = brandingFeatureConfig[brand] || brandingFeatureConfig.fyle;
    
    return featureConfig[featureName] === true;
  }

  getAvailableIntegrations(): string[] {
    const brand = this.brandingService.getBrand();
    
    if (brand === 'co') {
      return ['qbo', 'netsuite', 'intacct']; // Limited set for Capital One
    }
    
    // Full set for Fyle
    return [
      'qbo', 'xero', 'netsuite', 'intacct', 'sage300',
      'business-central', 'qbd', 'qbd-direct', 'bamboo-hr'
    ];
  }
}
```

### Content Customization
- **Help Articles**: Brand-specific help content
- **Demo Videos**: Integration-specific demo videos per brand
- **UI Text**: Customized labels and descriptions
- **Styling**: Brand-specific colors and themes

### Dynamic Content Loading
```typescript
// Content service for loading brand-specific content
@Injectable({
  providedIn: 'root'
})
export class ContentService {
  constructor(
    private brandingService: BrandingService,
    private http: HttpClient
  ) { }

  getHelpArticleUrl(articleKey: string): string {
    const brand = this.brandingService.getBrand();
    const contentConfig = this.brandingService.getContentConfig();
    
    return contentConfig.helpArticles[brand][articleKey] || 
           contentConfig.helpArticles.default[articleKey];
  }

  getIntegrationDescription(integrationKey: string): string {
    const brand = this.brandingService.getBrand();
    const contentConfig = this.brandingService.getContentConfig();
    
    return contentConfig.integrationDescriptions[brand]?.[integrationKey] || 
           contentConfig.integrationDescriptions.default[integrationKey];
  }

  getDemoVideoUrl(integrationKey: string): string {
    const brand = this.brandingService.getBrand();
    const contentConfig = this.brandingService.getContentConfig();
    
    return contentConfig.demoVideos[brand]?.[integrationKey] || 
           contentConfig.demoVideos.default[integrationKey];
  }
}
```

## Development Best Practices

### Code Organization
- Follow the established folder structure
- Use shared components where possible
- Implement proper error handling
- Add comprehensive unit tests
- Document integration-specific quirks

### Integration Testing Strategy
- **Unit Tests**: Test components and services in isolation
- **Integration Tests**: Test interaction between components
- **E2E Tests**: Test full onboarding and export flows
- **API Mocks**: Use mock API responses for testing
- **Error Testing**: Verify error handling paths

```typescript
// Component test example
describe('IntegrationConnectorComponent', () => {
  let component: IntegrationConnectorComponent;
  let fixture: ComponentFixture<IntegrationConnectorComponent>;
  let connectorService: jasmine.SpyObj<ConnectorService>;
  let router: jasmine.SpyObj<Router>;

  beforeEach(() => {
    const connectorSpy = jasmine.createSpyObj('ConnectorService', ['connect']);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);
    
    TestBed.configureTestingModule({
      declarations: [IntegrationConnectorComponent],
      imports: [ReactiveFormsModule, SharedModule],
      providers: [
        { provide: ConnectorService, useValue: connectorSpy },
        { provide: Router, useValue: routerSpy }
      ]
    });
    
    fixture = TestBed.createComponent(IntegrationConnectorComponent);
    component = fixture.componentInstance;
    connectorService = TestBed.inject(ConnectorService) as jasmine.SpyObj<ConnectorService>;
    router = TestBed.inject(Router) as jasmine.SpyObj<Router>;
  });

  it('should create the component', () => {
    expect(component).toBeTruthy();
  });

  it('should initialize the form', () => {
    component.ngOnInit();
    expect(component.form).toBeTruthy();
    expect(component.form.get('credential1')).toBeTruthy();
    expect(component.form.get('credential2')).toBeTruthy();
  });

  it('should call connect service on form submit', () => {
    component.ngOnInit();
    const credentials = { credential1: 'value1', credential2: 'value2' };
    
    component.form.patchValue(credentials);
    connectorService.connect.and.returnValue(of({}));
    
    component.connect();
    
    expect(connectorService.connect).toHaveBeenCalledWith(credentials);
    expect(router.navigate).toHaveBeenCalledWith(['/integrations/integration/onboarding/configuration']);
  });

  it('should not call service if form is invalid', () => {
    component.ngOnInit();
    component.connect();
    
    expect(connectorService.connect).not.toHaveBeenCalled();
  });
});
```

### Performance Considerations
- **Lazy Loading**: All integration modules are lazy-loaded
- **Caching**: Cache API responses appropriately
- **OnPush**: Use OnPush change detection strategy
- **Bundle Size**: Monitor and optimize bundle sizes

### Documentation Requirements
- **Integration Guide**: Step-by-step setup instructions
- **API Documentation**: Document service methods
- **Component Documentation**: Document reusable components
- **Troubleshooting**: Common issues and solutions

## Integration Workflow Checklist

### Setup Phase
- [ ] Create integration module structure
- [ ] Define integration-specific models
- [ ] Create API service classes
- [ ] Implement connection/authentication flow
- [ ] Set up route guards and navigation

### Onboarding Flow
- [ ] Implement connector component
- [ ] Create configuration forms
- [ ] Add import settings component
- [ ] Create export settings component
- [ ] Implement mapping components
- [ ] Add onboarding completion screen

### Dashboard Implementation
- [ ] Create main dashboard component
- [ ] Add connection status monitoring
- [ ] Implement export logs view
- [ ] Create configuration management views
- [ ] Add mapping management components

### Testing and Quality
- [ ] Write unit tests for components
- [ ] Create integration tests for workflows
- [ ] Document integration specifics
- [ ] Create error handling strategy
- [ ] Optimize performance and bundle size

## Integration-Specific Features Reference

### QuickBooks Online Features
- OAuth 2.0 authentication
- Chart of accounts mapping
- Employee/vendor mapping
- Bank account mapping
- Journal entry configuration
- Expense report configuration
- Tax configuration

### NetSuite Features
- Token-based authentication
- Subsidiary support
- Custom segment mapping
- Department and location mapping
- Complex classification fields
- Credit card integration
- Multi-currency support

### Xero Features
- OAuth 2.0 authentication 
- Organization selection
- Chart of accounts mapping
- Tracking categories mapping
- Contact mapping
- Tax rate configuration
- Bill/invoice configuration

### Sage Intacct Features
- Token-based authentication
- Dimension mapping
- Location entity mapping
- Department mapping
- Project mapping
- Custom field mapping
- Vendor mapping

### Implementation Timeline Guidelines
- Simple Integration: 2-3 weeks
- Medium Complexity: 3-5 weeks
- Complex Integration (NetSuite): 5-8 weeks
- Feature Additions: 1-2 weeks per feature
- Testing and QA: 1-2 weeks



