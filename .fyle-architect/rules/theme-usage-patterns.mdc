---
description: 
globs: 
alwaysApply: false
---
# Theme System Usage Patterns

## Importing Theme Configuration
```typescript
// Main branding config 
import { brandingConfig } from 'src/app/branding/branding-config';

// Feature flags
import { brandingFeatureConfig } from 'src/app/branding/branding-config';

// Style configuration
import { brandingStyle } from 'src/app/branding/branding-config';

// KB articles
import { brandingKbArticles } from 'src/app/branding/branding-config';

// Demo video links
import { brandingDemoVideoLinks } from 'src/app/branding/branding-config';

// App availability
import { exposeAppConfig } from 'src/app/branding/expose-app-config';
```

## Best Practices for Theme Implementation

### Feature Flags vs Direct Brand Checks

#### ‚úÖ PREFERRED: Use Feature Flags for All Theme-Specific Behavior
```typescript
// Business Logic: Use specific feature flags
if (!this.brandingFeatureConfig.featureFlags.exportSettings.isReimbursableExpensesAllowed) {
  this.exportSettingsForm.patchValue({
    creditCardExpense: true
  });
}

// UI Rendering: Use feature flags in templates
<div *ngIf="brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses" 
     class="reimbursable-options">
  <!-- Reimbursable expenses configuration -->
</div>

// Component Property: Use feature flags for conditional properties
get showNameInJournalOptions(): boolean {
  return this.brandingFeatureConfig.featureFlags.exportSettings.nameInJournalEntry;
}
```

#### ‚ùå AVOID: Direct Brand ID Checks
```typescript
// AVOID: Direct brand ID checks for business logic
if (this.brandingConfig.brandId === 'co') {
  this.exportSettingsForm.patchValue({
    creditCardExpense: true
  });
}

// AVOID: Direct brand ID checks in templates
<div *ngIf="brandingConfig.brandId === 'co'" class="co-specific-banner">
  <!-- Capital One-specific UI element -->
</div>
```

#### üîÑ When to Consider Adding a New Feature Flag
If you need to implement theme-specific behavior and there's no existing feature flag that covers your use case:

1. Check if the behavior is already controlled by an existing feature flag
2. If not, consider adding a new feature flag in the appropriate section:
   - `src/app/branding/fyle/branding-config.ts` - For Fyle theme
   - `src/app/branding/c1/branding-config.ts` - For Capital One theme

Example of adding a new feature flag:
```typescript
// In src/app/branding/c1/branding-config.ts
export const c1FeatureConfig: FeatureConfiguration[string] = {
  // existing configuration...
  featureFlags: {
    // existing flags...
    exportSettings: {
      // existing export settings...
      newFeatureFlag: false // Add your new flag here
    }
  }
};

// In src/app/branding/fyle/branding-config.ts
export const fyleFeatureConfig: FeatureConfiguration[string] = {
  // existing configuration...
  featureFlags: {
    // existing flags...
    exportSettings: {
      // existing export settings...
      newFeatureFlag: true // Add your new flag here
    }
  }
};
```

## Brand Detection Pattern
```typescript
// Import branding config
import { brandingConfig } from 'src/app/branding/branding-config';

// Check current brand
const isFyleBrand = brandingConfig.brandId === 'fyle';
const isCapitalOneBrand = brandingConfig.brandId === 'co';

// Use in template
<div *ngIf="brandingConfig.brandId === 'fyle'">
  <!-- Fyle-specific UI -->
</div>
<div *ngIf="brandingConfig.brandId === 'co'">
  <!-- Capital One-specific UI -->
</div>
```

## Feature Flag Usage Patterns

### Component-Level Feature Flag Usage
```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { brandingFeatureConfig } from 'src/app/branding/branding-config';

@Component({
  selector: 'app-export-settings',
  templateUrl: './export-settings.component.html'
})
export class ExportSettingsComponent implements OnInit {
  // Expose feature config to template
  readonly brandingFeatureConfig = brandingFeatureConfig;
  
  // Compute derived properties
  get showReimbursableOptions(): boolean {
    return brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses;
  }
  
  get showMerchantOptions(): boolean {
    return brandingFeatureConfig.featureFlags.exportSettings.useMerchantInJournalLine;
  }
  
  // Configure component based on brand
  ngOnInit(): void {
    if (brandingFeatureConfig.featureFlags.exportSettings.isEmployeeMappingFixed) {
      this.disableEmployeeMapping();
    }
  }
  
  private disableEmployeeMapping(): void {
    // Implementation details
  }
}
```

### Component Template Usage
```html
<!-- Component template -->
<div class="export-settings-container">
  <!-- Show/hide based on feature flag -->
  <div *ngIf="brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses" 
       class="reimbursable-options">
    <!-- Reimbursable expenses configuration -->
  </div>
  
  <!-- Show/hide merchant options -->
  <div *ngIf="brandingFeatureConfig.featureFlags.exportSettings.useMerchantInJournalLine" 
       class="merchant-options">
    <!-- Merchant options configuration -->
  </div>
  
  <!-- Use computed property for clarity -->
  <div *ngIf="showMerchantOptions" class="additional-merchant-settings">
    <!-- More merchant settings -->
  </div>
  
  <!-- Control UI elements based on feature flags -->
  <button [disabled]="!brandingFeatureConfig.featureFlags.advancedSettings.skipExport">
    Configure Skip Export
  </button>
</div>
```

### Form Control Management Based on Feature Flags
```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { brandingFeatureConfig } from 'src/app/branding/branding-config';

@Component({
  selector: 'app-export-settings-form',
  templateUrl: './export-settings-form.component.html'
})
export class ExportSettingsFormComponent implements OnInit {
  exportSettingsForm: FormGroup;
  
  constructor(private fb: FormBuilder) {}
  
  ngOnInit(): void {
    this.createForm();
  }
  
  private createForm(): void {
    this.exportSettingsForm = this.fb.group({
      creditCardExpense: [false],
      reimbursableExpense: [false],
      useMerchantInJournalLine: [false],
      nameInJournalEntry: ['EMPLOYEE']
    });
    
    // Remove controls based on feature flags
    if (!brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses) {
      this.exportSettingsForm.removeControl('reimbursableExpense');
    }
    
    if (!brandingFeatureConfig.featureFlags.exportSettings.useMerchantInJournalLine) {
      this.exportSettingsForm.removeControl('useMerchantInJournalLine');
    }
    
    // Set default values based on feature flags
    if (!brandingFeatureConfig.featureFlags.exportSettings.isReimbursableExpensesAllowed) {
      this.exportSettingsForm.patchValue({
        creditCardExpense: true
      });
    }
  }
}
```

## Style Configuration Patterns

### Component with Brand-Specific Styling
```typescript
// Component TypeScript file
import { Component } from '@angular/core';
import { brandingStyle } from 'src/app/branding/branding-config';

@Component({
  selector: 'app-configuration-panel',
  templateUrl: './configuration-panel.component.html'
})
export class ConfigurationPanelComponent {
  // Expose style config to template
  readonly brandingStyle = brandingStyle;
  
  // Computed style properties
  get containerClasses(): string {
    return brandingStyle.common.configurationContents;
  }
  
  get mappingHeaderClasses(): string {
    return brandingStyle.mapping.mappingHeaderBoxShadow;
  }
  
  get importFieldClasses(): string {
    return brandingStyle.configuration.importFieldDropDownText;
  }
}
```

### Component Template with Brand-Specific Styling
```html
<!-- Component template -->
<div [ngClass]="containerClasses">
  <!-- Container with brand-specific styling -->
  
  <!-- Direct usage of style config -->
  <div [ngClass]="brandingStyle.common.mainComponentPadding">
    <!-- Content with padding -->
  </div>
  
  <!-- Mapping header with brand-specific shadow -->
  <div [ngClass]="mappingHeaderClasses">
    <!-- Mapping header content -->
  </div>
  
  <!-- Import field with brand-specific text style -->
  <div [ngClass]="importFieldClasses">
    <!-- Import field content -->
  </div>
</div>
```

## Integration Availability Pattern

### Service for Integration Availability
```typescript
// Service TypeScript file
import { Injectable } from '@angular/core';
import { exposeAppConfig } from 'src/app/branding/expose-app-config';
import { brandingConfig } from 'src/app/branding/branding-config';

@Injectable({
  providedIn: 'root'
})
export class IntegrationAvailabilityService {
  /**
   * Check if an integration is available in the current environment
   * @param integrationName Integration identifier (e.g., 'QBO', 'INTACCT')
   * @returns boolean indicating if the integration is available
   */
  isIntegrationAvailable(integrationName: string): boolean {
    // Check if integration exists in the current brand and environment
    const currentBrand = brandingConfig.brandId;
    const currentEnv = brandingConfig.envId;
    
    // Safely check if integration is available
    if (exposeAppConfig[currentBrand] && 
        exposeAppConfig[currentBrand][currentEnv]) {
      return !!exposeAppConfig[currentBrand][currentEnv][integrationName];
    }
    
    return false;
  }
  
  /**
   * Get list of all available integrations for current environment
   * @returns array of available integration names
   */
  getAvailableIntegrations(): string[] {
    const currentBrand = brandingConfig.brandId;
    const currentEnv = brandingConfig.envId;
    const availableIntegrations: string[] = [];
    
    if (exposeAppConfig[currentBrand] && 
        exposeAppConfig[currentBrand][currentEnv]) {
      
      // Get all integrations and filter by availability
      const envConfig = exposeAppConfig[currentBrand][currentEnv];
      Object.keys(envConfig).forEach(integration => {
        if (envConfig[integration]) {
          availableIntegrations.push(integration);
        }
      });
    }
    
    return availableIntegrations;
  }
}
```

### Component Using Integration Availability
```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { IntegrationAvailabilityService } from '../../services/integration-availability.service';

@Component({
  selector: 'app-integration-selection',
  templateUrl: './integration-selection.component.html'
})
export class IntegrationSelectionComponent implements OnInit {
  availableIntegrations: string[] = [];
  
  constructor(private integrationService: IntegrationAvailabilityService) {}
  
  ngOnInit(): void {
    // Get list of all available integrations
    this.availableIntegrations = this.integrationService.getAvailableIntegrations();
  }
  
  isAvailable(integration: string): boolean {
    return this.integrationService.isIntegrationAvailable(integration);
  }
}
```

### Component Template with Integration Availability
```html
<!-- Component template -->
<div class="integration-selection">
  <h2>Available Integrations</h2>
  
  <!-- Only show integrations that are available -->
  <div class="integration-grid">
    <div *ngIf="isAvailable('QBO')" class="integration-card">
      <!-- QBO integration card -->
    </div>
    
    <div *ngIf="isAvailable('INTACCT')" class="integration-card">
      <!-- Intacct integration card -->
    </div>
    
    <div *ngIf="isAvailable('SAGE300')" class="integration-card">
      <!-- Sage 300 integration card -->
    </div>
    
    <!-- Dynamic list of all available integrations -->
    <ng-container *ngFor="let integration of availableIntegrations">
      <div class="integration-card">
        <!-- Dynamic integration card -->
        {{ integration }}
      </div>
    </ng-container>
  </div>
</div>
```

## KB Articles and Demo Videos Pattern

### Service for Documentation Links
```typescript
// Service TypeScript file
import { Injectable } from '@angular/core';
import { brandingKbArticles, brandingDemoVideoLinks } from 'src/app/branding/branding-config';

@Injectable({
  providedIn: 'root'
})
export class DocumentationService {
  /**
   * Get KB article link for specific integration and article type
   * @param integration Integration identifier (e.g., 'QBO', 'INTACCT')
   * @param articleType Article type (e.g., 'LANDING', 'EXPORT_SETTING')
   * @returns URL string for the KB article
   */
  getKbArticleLink(integration: string, articleType: string): string {
    // Top level articles
    if (brandingKbArticles.topLevelArticles && 
        brandingKbArticles.topLevelArticles[integration]) {
      return brandingKbArticles.topLevelArticles[integration];
    }
    
    // Onboarding articles
    if (brandingKbArticles.onboardingArticles && 
        brandingKbArticles.onboardingArticles[integration]) {
      const integrationArticles = brandingKbArticles.onboardingArticles[integration];
      
      if (integrationArticles && integrationArticles[articleType]) {
        return integrationArticles[articleType];
      }
    }
    
    // Default fallback
    return '';
  }
  
  /**
   * Get demo video link for specific integration
   * @param integration Integration identifier (e.g., 'QBO', 'INTACCT')
   * @returns URL string for the demo video
   */
  getDemoVideoLink(integration: string): string {
    if (brandingDemoVideoLinks.onboarding && 
        brandingDemoVideoLinks.onboarding[integration]) {
      return brandingDemoVideoLinks.onboarding[integration];
    }
    
    // Default fallback
    return '';
  }
}
```

### Component Using Documentation Links
```typescript
// Component TypeScript file
import { Component, Input } from '@angular/core';
import { DocumentationService } from '../../services/documentation.service';

@Component({
  selector: 'app-integration-help',
  templateUrl: './integration-help.component.html'
})
export class IntegrationHelpComponent {
  @Input() integration: string;
  
  constructor(private docService: DocumentationService) {}
  
  get landingArticleLink(): string {
    return this.docService.getKbArticleLink(this.integration, 'LANDING');
  }
  
  get exportSettingsArticleLink(): string {
    return this.docService.getKbArticleLink(this.integration, 'EXPORT_SETTING');
  }
  
  get demoVideoLink(): string {
    return this.docService.getDemoVideoLink(this.integration);
  }
}
```

### Component Template with Documentation Links
```html
<!-- Component template -->
<div class="integration-help">
  <h3>Help Resources</h3>
  
  <!-- KB article links -->
  <div class="help-links">
    <a [href]="landingArticleLink" target="_blank" rel="noopener noreferrer">
      Getting Started Guide
    </a>
    
    <a [href]="exportSettingsArticleLink" target="_blank" rel="noopener noreferrer">
      Export Settings Documentation
    </a>
  </div>
  
  <!-- Demo video -->
  <div *ngIf="demoVideoLink" class="demo-video">
    <h4>Demo Video</h4>
    <iframe [src]="demoVideoLink | safe" 
            width="560" height="315" 
            frameborder="0" 
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
            allowfullscreen>
    </iframe>
  </div>
</div>
```

## Handling Both Brands in Single Component

### ‚úÖ PREFERRED: Feature Flag-Based Configuration
```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { brandingFeatureConfig } from 'src/app/branding/branding-config';

@Component({
  selector: 'app-export-options',
  templateUrl: './export-options.component.html'
})
export class ExportOptionsComponent implements OnInit {
  // Configuration based directly on feature flags
  activeConfig = {
    showReimbursableSection: brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses,
    showMerchantFields: brandingFeatureConfig.featureFlags.exportSettings.useMerchantInJournalLine,
    allowSplitGrouping: brandingFeatureConfig.featureFlags.exportSettings.splitExpenseGrouping,
    useEmployeeAttributes: brandingFeatureConfig.featureFlags.advancedSettings.useEmployeeAttributes
  };
  
  ngOnInit(): void {
    // Additional initialization if needed
  }
}
```

### ‚ö†Ô∏è ACCEPTABLE: Brand-Based Configuration (Legacy Pattern)
```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { brandingConfig } from 'src/app/branding/branding-config';

@Component({
  selector: 'app-export-options',
  templateUrl: './export-options.component.html'
})
export class ExportOptionsComponent implements OnInit {
  // Store UI configuration for each brand
  uiConfig = {
    fyle: {
      showReimbursableSection: true,
      showMerchantFields: true,
      allowSplitGrouping: true
    },
    co: {
      showReimbursableSection: false,
      showMerchantFields: false,
      allowSplitGrouping: false
    }
  };
  
  // Current active configuration
  activeConfig: any;
  
  ngOnInit(): void {
    // Set active configuration based on brand
    this.activeConfig = this.uiConfig[brandingConfig.brandId] || this.uiConfig.fyle;
  }
}
```

## Complete Example: Export Settings Component

```typescript
// Component TypeScript file
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { 
  brandingConfig, 
  brandingFeatureConfig, 
  brandingKbArticles 
} from 'src/app/branding/branding-config';
import { ExportSettingsService } from '../services/export-settings.service';

@Component({
  selector: 'app-export-settings',
  templateUrl: './export-settings.component.html'
})
export class ExportSettingsComponent implements OnInit {
  exportSettingsForm: FormGroup;
  exportSettings: any;
  
  // Expose configs to template
  readonly brandingFeatureConfig = brandingFeatureConfig;
  readonly brandingKbArticles = brandingKbArticles;
  
  constructor(
    private fb: FormBuilder,
    private exportSettingsService: ExportSettingsService
  ) { }
  
  ngOnInit(): void {
    this.createForm();
    this.getExportSettings();
  }
  
  private createForm(): void {
    this.exportSettingsForm = this.fb.group({
      creditCardExpense: [false],
      // Add other form controls
    });
    
    // Remove controls based on feature flags
    if (!this.brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses) {
      this.exportSettingsForm.removeControl('reimbursableExpense');
    }
    
    if (!this.brandingFeatureConfig.featureFlags.exportSettings.useMerchantInJournalLine) {
      this.exportSettingsForm.removeControl('useMerchantInJournalLine');
    }
  }
  
  private getExportSettings(): void {
    this.exportSettingsService.getExportSettings().subscribe(settings => {
      this.exportSettings = settings;
      
      // Apply default values based on feature flags
      if (!this.brandingFeatureConfig.featureFlags.exportSettings.isReimbursableExpensesAllowed 
          && !this.exportSettings?.credit_card_expense_export_type) {
        this.exportSettingsForm.patchValue({
          creditCardExpense: true
        });
      }
      
      // Other form patching logic
    });
  }
  
  get helpArticleLink(): string {
    return this.brandingKbArticles.onboardingArticles.QBD_DIRECT.EXPORT_SETTING;
  }
  
  get showNameInJournalOptions(): boolean {
    return this.brandingFeatureConfig.featureFlags.exportSettings.nameInJournalEntry;
  }
}
```

```html
<!-- Component template -->
<div class="export-settings">
  <form [formGroup]="exportSettingsForm">
    <!-- Credit Card Expense section (always shown) -->
    <div class="form-section">
      <label>Credit Card Expense</label>
      <p-inputSwitch formControlName="creditCardExpense"></p-inputSwitch>
    </div>
    
    <!-- Reimbursable Expense section (conditionally shown) -->
    <div *ngIf="brandingFeatureConfig.featureFlags.exportSettings.reimbursableExpenses" 
         class="form-section">
      <label>Reimbursable Expense</label>
      <p-inputSwitch formControlName="reimbursableExpense"></p-inputSwitch>
    </div>
    
    <!-- Help link -->
    <div class="help-section">
      <a [href]="helpArticleLink" target="_blank">
        Learn more about export settings
      </a>
    </div>
  </form>
</div>
```

